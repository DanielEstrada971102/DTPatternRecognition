# ------------------------------- configuration for Event -------------------------------------#
# follow this format to specify particles to be built:
# particle_types:
#   ...
#   particle_name:
#     class: 'path.to.particle_class', if not defined it will use the default 'dtpr.particles.Particle' class
#     amount: (int, TBranch<int> or TBranch<vector>) that could define how many particles to build  
#     branches: list of branches to be used as attributes 
#       attr_name: 'branch_name' 
#       ...
#     attributes: Other attributes that can be put directly or computed with a expression or a method
#       attr_name: (value)
#         expr: 'expression' to define the attribute, it expects a expression that can use any of 
#                the class attributes directly
#         src: 'src' to define the attribute, it expects the path to a method that receives 
#                 the particle as input
#     filter: condition to filter the particles that want to be built, it expects a expression that
#             can use the particle instace (ref as 'p') and the root event entry (ref as 'ev')
#     sorter: how to sort the particles
#       by: A expresion to execute to decide the order. it expects a expression that can use the 
#           particle instance (ref as 'p') and the root event entry (ref as 'ev')
#       reverse: True/False to sort in reverse order. If not indicated default is False
#
# ================= available particles - dtntuple ================= #
# comment/uncomment/add as needed...
particle_types:
  digis:
    amount: 'digi_nDigis'
    attributes:
      wh: 
        branch: 'digi_wheel'
      sc: 
        branch: 'digi_sector'
      st: 
        branch: 'digi_station'
      sl: 
        branch: 'digi_superLayer'
      w: 
        branch: 'digi_wire'
      l: 
        branch: 'digi_layer'
      time: 
        branch: 'digi_time'
      BX:
        expr: 'time // 25 if time is not None else None'
    sorter:
      by: 'p.BX'
  segments:
    amount: 'seg_nSegments'
    attributes:
      wh: 
        branch: 'seg_wheel'
      sc: 
        branch: 'seg_sector'
      st: 
        branch: 'seg_station'
      phi: 
        branch: 'seg_posGlb_phi'
      eta: 
        branch: 'seg_posGlb_eta'
      nHits_phi: 
        branch: 'seg_phi_nHits'
      nHits_z: 
        branch: 'seg_z_nHits'
      t0_phi: 
        branch: 'seg_phi_t0'
      pos_locx_sl1: 
        branch: 'seg_posLoc_x_SL1'
      pos_locx_sl3: 
        branch: 'seg_posLoc_x_SL3'
      matched_genmuons: []
      matched_tps: []
  tps:  
    amount: 'ph2TpgPhiEmuAm_nTrigs'
    attributes:
      wh: 
        branch: 'ph2TpgPhiEmuAm_wheel'
      sc: 
        branch: 'ph2TpgPhiEmuAm_sector'
      st: 
        branch: 'ph2TpgPhiEmuAm_station'
      sl:
        branch: 'ph2TpgPhiEmuAm_superLayer'
      phi: 
        branch: 'ph2TpgPhiEmuAm_phi'
      phiB: 
        branch: 'ph2TpgPhiEmuAm_phiB'
      posLoc_x:
        branch: 'ph2TpgPhiEmuAm_posLoc_x'
      dirLoc_phi:
        branch: 'ph2TpgPhiEmuAm_dirLoc_phi'
      quality: 
        branch: 'ph2TpgPhiEmuAm_quality'
      rpcFlag: 
        branch: 'ph2TpgPhiEmuAm_rpcFlag'
      _BX: # first get the BX from the branch
        branch: 'ph2TpgPhiEmuAm_BX'
      BX: # then re-define the BX attribute to center it at 0
        expr: '_BX - 20'
      phires_conv:
        expr: '65536.0 / 0.5'
      matched_segments: []
      matched_genmuons: []
      matched_showers: []
    filter: 'p.quality >= 0'
  genmuons:
    amount: 'gen_nGenParts'
    attributes:
      pt: 
        branch: 'gen_pt'
      eta: 
        branch: 'gen_eta'
      phi: 
        branch: 'gen_phi'
      charge: 
        branch: 'gen_charge'
      matched_segments: []
      matched_tps: []
      showered: False
    filter: 'abs(ev.gen_pdgId[p.index]) == 13'
    sorter:
      by: 'p.pt'
      reverse: True
  fwshowers:
    amount: 'ph2Shower_station'
    attributes:
      wh: 
        branch: 'ph2Shower_wheel'
      sc: 
        branch: 'ph2Shower_sector'
      st: 
        branch: 'ph2Shower_station'
      sl: 
        branch: 'ph2Shower_superlayer'
      nDigis: 
        branch: 'ph2Shower_ndigis'
      BX: 
        branch: 'ph2Shower_BX'
      min_wire: 
        branch: 'ph2Shower_min_wire'
      max_wire: 
        branch: 'ph2Shower_max_wire'
      avg_pos: 
        branch: 'ph2Shower_avg_pos'
      avg_time: 
        branch: 'ph2Shower_avg_time'
      wires_profile: 
        branch: 'ph2Shower_wires_profile'
      matched_tps: []
  simhits:
    amount: 'simHit_nSimHits'
    attributes:
      wh: 
        branch: 'simHit_wheel'
      sc: 
        branch: 'simHit_sector'
      st: 
        branch: 'simHit_station'
      sl: 
        branch: 'simHit_superLayer'
      l: 
        branch: 'simHit_layer'
      w: 
        branch: 'simHit_wire'
      process_type: 
        branch: 'simHit_processType'
      particle_type: 
        branch: 'simHit_particleType'

# -------------------------------- configuration for NTuple --------------------------------------#
ntuple_tree_name: '/dtNtupleProducer/DTTREE'

# =============== available preprocessors - dtntuple ================= #
# define the preprocessors to be used in the ntuple, follow the format:
# preprocessor_name: Any name, not relevant to the codes
#   src: 'path.to.preprocessor'
#   kwargs: # optional arguments to be passed to the preprocessor
#     arg1: value1
#     ...
# ...
ntuple_preprocessors:
  # # define the event preprocessors to be used in the ntuple
  genmuon_matcher:
    src: "dtpr.utils.genmuon_functions.analyze_genmuon_matches"

# ================= available selectors - dtntuple ================= #
# define the selectors to be used in the ntuple, follow the format:
# selector_name: Any name, not relevant to the codes
#   src: 'path.to.selector' 
#   kwargs: # optional arguments to be passed to the selector
#     arg1: value1
#     ...
# ...
ntuple_selectors:
# comment/uncomment/add as needed...
  baseline:
    src: "dtpr.utils.filters.base_filters.baseline"

# -------------------------------- configuration for histograms -----------------------------------#
histo_sources:
  # define the source modules of the histograms
  - dtpr.utils.histograms.genmuon_histos
  - dtpr.utils.histograms.am_histos

histo_names:
  # Histogram to fill - Uncomment or add histograms as needed. 
  # They should exist in any of the source modules
  # # ============ efficiencies ============ #
  - seg_eff_MB1
  - seg_eff_MB2
  - seg_eff_MB3
  - seg_eff_MB4
  # ============== rates =============== #
  - AM_rate_allBX_MB1
  - AM_rate_allBX_MB2
  - AM_rate_allBX_MB3
  - AM_rate_allBX_MB4
  - AM_rate_goodBX_MB1
  - AM_rate_goodBX_MB2
  - AM_rate_goodBX_MB3
  - AM_rate_goodBX_MB4
  # ============ leading_mu ============ #
  - LeadingMuon_pt
  - LeadingMuon_eta
  - LeadingMuon_maxDPhi
  - LeadingMuon_maxDEta
  # =========== subleading_mu ========== #
  - SubLeadingMuon_pt
  - SubLeadingMuon_eta
  - SubLeadingMuon_maxDPhi
  - SubLeadingMuon_maxDEta
  # ============= other_vars =========== #
  - muon_DR
  - nGenMuons
  - dphimax_seg_showering_muon
  - dphimax_seg_non_showering_muon
  - dphimax_tp_showering_muon
  - dphimax_tp_non_showering_muon
  - dphi_seg_showering_muon
  - dphi_seg_non_showering_muon
  - dphi_tp_showering_muon
  - dphi_genmuon_showering_muon

# ----------------------------- configuration for event inspector ---------------------------------#
# inspector-functions:
  # define the functions to be used in the event inspector in the format:
  # func1:
  #   src: "..."
  #   kwargs:
  #     arg1: value1
  #     ...
  #   ...

# ------------------------------- configuration for dt plots  -------------------------------------#
plot_configs:
  mplhep-style: 'CMS'         # Style to use for the plots

  figure-configs: 
    figure.dpi: 100             # Dots per inch (resolution)
    axes.titlesize: 'small'     # Axes title size
    axes.labelsize: 'x-small'    # Axes label size
    xtick.labelsize: 'x-small'    # X-axis tick label size
    ytick.labelsize: 'x-small'    # Y-axis tick label size
    legend.fontsize: 'small'   # Legend font size

  artists:
    # artists to be used in the DT plots
    dt-station-global: &dt-station-global 
      src: "dtpr.utils.dt_plot_functions.embed_dts2axes"  # Source of the artist
      rep-info:
        particle_type: 'digis'      # Particle type to use
        cmap_var: 'time'            # Variable to use for the colormap

      # DT bounds and cells are matplotlib.patches.Rectangle objects
      bounds_kwargs:
        facecolor: ["lightgray", "lightyellow", "lightpink", "lightblue"]   # Color of the rectangle [MB, SL1, SL3, SL2]
        edgecolor: "k"                                                      # Color of the edge
        alpha: 0.3                                                          # Transparency of the rectangle
        linewidth: 0.5                                                      # Width of the edge

      cells_kwargs:
        edgecolor: "k"              # Color of the edge
        linewidth: 0.025              # Width of the edge
        cmap: 'viridis'             # Colormap to use, list of colors or {name, N} dict
        norm: # from matplotlib.colors
          class: 'Normalize'  # Normalization class
          vmin: 299                             # Minimum value for normalization
          vmax: 1000                            # Maximum value for normalization

    dt-station-local:
      <<: *dt-station-global
      src: "dtpr.utils.dt_plot_functions.embed_dt2axes"

    dt-segment-global: &dt-segment-global
      src: "dtpr.utils.dt_plot_functions.test_builder"  # dummy function as placeholder; replace with actual implementation when available
      rep-info:
        particle_type: 'segments'  # Particle type to use
        cmap_var: 'matched_genmuons'  # Variable to use for the colormap
      segs_kwargs:
        linewidth: 0.8
        cmap: ["k", 'r']             # Colormap to use
        norm:
          class: 'BoundaryNorm'  # Normalization class
          boundaries: [0, 1, 2]      # Boundaries for the col
          ncolors: 2                 # Number of colors in the colormap

    dt-segment-local:
      <<: *dt-segment-global

    dt-am-tps-global: &dt-am-tps-global
      src: "dtpr.utils.dt_plot_functions.embed_segs2axes_glob"  # Source of the artist
      rep-info:
        particle_type: 'tps'  # Particle type to use
        cmap_var: 'quality'   # Variable to use for the colormap
      segs_kwargs:
        linewidth: 0.8
        cmap:                 # Colormap to use
          name: 'viridis'
          N: 9
        norm:
          class: 'BoundaryNorm'  # Normalization class
          boundaries: [0.1, 1, 2, 3, 4, 5, 6, 7, 8, 9]      # Boundaries for the colormap
          ncolors: 9                 # Number of colors in the colormap
          clip: True  # Clip values outside the boundaries

    dt-am-tps-local:
      <<: *dt-am-tps-global
      src: "dtpr.utils.dt_plot_functions.embed_segs2axes_loc"  # Source of the artist

    dt-simhits-local:
      src: "dtpr.utils.dt_plot_functions.embed_simhits2axes_loc"  # Source of the artist
      rep-info:
        particle_type: 'simhits'  # Particle type to use

    dt-showers-global: &dt-shower-global
      src: "dtpr.utils.dt_plot_functions.embed_shower2axes_glob"  # Source of the artist
      rep-info:
        particle_type: 'fwshowers'  # Particle type to use
      color: 'red'
      linewidth: 3

    dt-showers-local:
      <<: *dt-shower-global
      src: "dtpr.utils.dt_plot_functions.embed_shower2axes_loc"  # Source of the artist

    cms-shadow-global:
      src: "dtpr.utils.dt_plot_functions.embed_cms_global_shadow"  # Source of the artist
      edgecolor: 'black'
      facecolor: "gray"
      alpha: 0.1
      linewidth: 0.5
